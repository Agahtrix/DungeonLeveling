<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Dungeon Leveling</title>
    <style>
        /* CSS Variables  */
        :root {
            --bg-color-main: #1a1a1a;
            --bg-color-container: #2d2d2d;
            --bg-color-section: #333;
            --bg-color-input: #444;
            --bg-color-log: #252525;
            --text-color-light: #e0e0e0;
            --text-color-medium: #ccc;
            --text-color-dark: #1a1a1a;
            --border-color: #555;
            --border-color-light: #444;
            --accent-color-primary: #00aeff; /* Title, highlights */
            --accent-color-secondary: #bb86fc; /* Section titles */
            --accent-color-action: #03dac6; /* Action buttons */
            --accent-color-action-hover: #01bfaa;
            --color-error: #cf6679;
            --color-success: #66bb6a;
            --color-danger: #dc3545;
            --color-danger-hover: #a71d2a;
            --color-primary-btn: #007bff;
            --color-primary-btn-hover: #0056b3;
            --border-radius-small: 4px;
            --border-radius-medium: 6px;
            --border-radius-large: 10px;
            --spacing-small: 5px;
            --spacing-medium: 10px;
            --spacing-large: 15px;
            --spacing-xlarge: 20px;
            --font-size-base: 1rem;
            --font-size-small: 0.9rem;
            --font-size-large: 1.1rem;
            --font-size-h2: 1.8rem;
            --font-size-h3: 1.2rem;
            --transition-speed: 0.2s;
        }

        /* Basic Reset & Defaults  */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 100%; }
        body {
            font-family: 'Roboto', Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: var(--spacing-large);
            background-color: var(--bg-color-main);
            color: var(--text-color-light);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        /* Container  */
        .container {
            width: 100%;
            max-width: 700px;
            margin: 0 auto;
            background: var(--bg-color-container);
            padding: var(--spacing-large) var(--spacing-xlarge);
            border-radius: var(--border-radius-large);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
        }

        /* Headings and Text  */
        .page-title { text-align: center; margin-bottom: var(--spacing-xlarge); color: var(--accent-color-primary); font-size: var(--font-size-h2); }
        h3 { font-size: var(--font-size-h3); margin-top: 0; margin-bottom: var(--spacing-medium); color: var(--accent-color-secondary); border-bottom: 1px solid var(--border-color-light); padding-bottom: var(--spacing-small); }

        /* Messages  */
        .loading-indicator, .error-message, .game-over-message { text-align: center; padding: var(--spacing-medium); margin-bottom: var(--spacing-large); border-radius: var(--border-radius-small); transition: opacity var(--transition-speed) ease-in-out; }
        .loading-indicator { font-style: italic; color: var(--text-color-medium); }
        .error-message { color: var(--color-error); font-weight: bold; background-color: rgba(207, 102, 121, 0.1); border-left: 3px solid var(--color-error); text-align: left; }
        .game-over-message { font-weight: bold; color: var(--color-error); font-size: 1.5rem; background-color: rgba(45, 45, 45, 0.8); }

        /* Forms & Inputs  */
        .form-section { margin-bottom: var(--spacing-xlarge); padding: var(--spacing-large); background-color: var(--bg-color-section); border-radius: var(--border-radius-medium); }
        #character-creation { background-color: #383838; }
        .character-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .char-thumb {
            width: 64px;
            height: 64px;
            object-fit: contain;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border-color 0.2s;
        }
        .char-thumb:hover {
            border-color: #aaa;
        }
        .char-thumb.selected {
            border-color: #007bff;
        }

        .form-group { margin-bottom: var(--spacing-large); }
        .form-group label { display: block; margin-bottom: var(--spacing-small); font-weight: bold; color: var(--text-color-medium); }
        input[type="text"], input[type="number"] { width: 100%; padding: var(--spacing-medium); border: 1px solid var(--border-color); background-color: var(--bg-color-input); color: var(--text-color-light); border-radius: var(--border-radius-small); font-size: var(--font-size-base); }
        input[type="text"]:focus, input[type="number"]:focus { outline: none; border-color: var(--accent-color-primary); box-shadow: 0 0 5px rgba(0, 174, 255, 0.5); }

        /* Buttons  */
        .btn { display: inline-block; padding: var(--spacing-medium) var(--spacing-large); margin: var(--spacing-small); font-size: var(--font-size-base); font-weight: bold; cursor: pointer; border: none; border-radius: var(--border-radius-small); text-align: center; transition: background-color var(--transition-speed) ease, transform var(--transition-speed) ease; color: var(--text-color-light); }
        .btn:hover { opacity: 0.9; }
        .btn:active { transform: scale(0.98); }
        .btn-primary { background-color: var(--color-primary-btn); }
        .btn-primary:hover { background-color: var(--color-primary-btn-hover); }
        .btn-danger { background-color: var(--color-danger); }
        .btn-danger:hover { background-color: var(--color-danger-hover); }
        .btn-action { background-color: var(--accent-color-action); color: var(--text-color-dark); }
        .btn-action:hover { background-color: var(--accent-color-action-hover); }
        .btn-secondary { background-color: var(--bg-color-input); color: var(--text-color-light); border: 1px solid var(--border-color); }
        .btn-secondary:hover { background-color: var(--border-color); }
        #start-form button[type="submit"]
        

        /* Game Status Layout  */
        .stats-area { display: flex; flex-wrap: wrap; gap: var(--spacing-xlarge); margin-bottom: var(--spacing-xlarge); }
        .stats-section { flex: 1; min-width: 220px; background-color: var(--bg-color-section); padding: var(--spacing-large); border-radius: var(--border-radius-medium); }
        .stats-content { line-height: 1.8; }
        .stats-content span { display: block; margin-bottom: var(--spacing-small); }
        .stats-content strong { min-width: 70px; display: inline-block; }

        /* --- Map Area Styles --- */
        .map-section {
            margin-bottom: var(--spacing-xlarge);
            background: var(--bg-color-section);
            padding: var(--spacing-large);
            border-radius: var(--border-radius-medium);
        }
        .map-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-medium);
        }
        .map-header h3 { margin-bottom: 0; border-bottom: none; }
        #zoom-button, #restart-button {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 1000;
            padding: var(--spacing-small) var(--spacing-medium);
            font-size: var(--font-size-small);
            border-radius: 999px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        #restart-button {
            left: 1rem;
            right: auto;
        }
        
        /* --- MODIFIED: .map-area --- */
        .map-area {
            position: relative; /* Needed for absolute positioning of icons */
            display: block; /* Allows margin: auto and correct icon origin */
            margin: 0 auto; /* Center the block element horizontally */
            width: fit-content; /* Make container width match the image width */
            max-width: 100%; /* Prevent overflow if image is wider than container */
            background-color: var(--bg-color-input);
            border-radius: var(--border-radius-small);
            overflow: hidden; /* Clip icons if they go outside */
            min-height: 200px; /* Ensure area has height */
            border: 1px solid var(--border-color);
            transform-origin: top left; /* Ensure transforms originate correctly */
            transition: transform 0.3s ease; /* Smooth panning transition */
        }

        #map-image, #map-canvas {
            display: block; /* Remove extra space below image/canvas */
            max-width: 100%; /* Ensure image scales down if needed */
            height: auto;    /* Maintain aspect ratio for image */
            transition: opacity var(--transition-speed) ease-in-out;
            
        }

        /* --- MODIFIED: #map-canvas --- */
        #map-canvas {
            /* display: block; /* Already set above */
            /* Define fixed size for canvas */
            width: 400px; /* Match the HTML attribute */
            height: 400px; /* Match the HTML attribute */
            /* Sharpen pixel art on zoom */

            image-rendering: -webkit-optimize-contrast; /* Possibly future standard */
            image-rendering: pixelated; /* Standard */
        }

        /* --- MODIFIED: .character-icon --- */
        .character-icon {
            position: absolute;
            /* Size for the NON-ZOOMED view (using <img> tags) */
            width: 24px;
            height: 24px;
            z-index: 10;
            /* transform-origin: center center; */
            /* Improves rendering for pixel art if char.png is low-res */
            image-rendering: pixelated; /* Or auto */
            pointer-events: none;
            transition: top var(--transition-speed) ease, left var(--transition-speed) ease, transform var(--transition-speed) ease;
        }

        .enemy-icon {
            z-index: 5;
        }

        /* Separator  */
        .separator { border: 0; height: 1px; background: var(--border-color-light); margin: var(--spacing-xlarge) 0; }

        /* Log Area  */
        /* ‚Äî‚Äî‚Äî‚Äî‚Äî Default (large screens) ‚Äî‚Äî‚Äî‚Äî‚Äî */
        .log-section {
            position: fixed;
            top: 3rem;
            right: 0rem;
            z-index: 1000;
            width: 20vw;
            /* max-width: 700px; */
            height: 90vh;        /* almost full height */
            padding: var(--spacing-small) var(--spacing-medium);
            pointer-events: auto;
            display: flex;
            flex-direction: column;
        }

        #log-content {
            flex: 1;             /* fill the .log-section vertically */
            overflow-y: auto;
            min-width: 0;        /* for flex children */
            border: 1px solid var(--border-color-light);
            padding: var(--spacing-medium);
            background: transparent;
            border-radius: var(--border-radius-medium);
            font-size: var(--font-size-small);
            line-height: 1.8;
            color: var(--text-color-medium);
            scroll-behavior: smooth;
        }

        /* scrollbar styling stays the same */
        #log-content::-webkit-scrollbar { width: 8px; }
        #log-content::-webkit-scrollbar-track  { background: var(--bg-color-section); border-radius: 4px; }
        #log-content::-webkit-scrollbar-thumb  { background-color: var(--border-color); border-radius: 4px; border: 2px solid var(--bg-color-section); }


        /* ‚Äî‚Äî‚Äî‚Äî‚Äî Smaller screens: drop below the map ‚Äî‚Äî‚Äî‚Äî‚Äî */
        @media (max-width: 1159px) {
            .log-section {
                position: static;        /* no longer fixed */
                width: 100%;             /* full container width */
                line-height: 0.6;
                height: auto;            /* shrink to content + max-height below */
                max-height: 20vh;        /* short vertical footprint */
                margin: var(--spacing-medium) 0; /* space above & below */
                pointer-events: auto;    /* if you want users to scroll the log */
            }

            #log-content {
                line-height: 1.5;
                max-height: 100%;       /* let the parent‚Äôs 20vh control it */
            }
        }


        /* Action Buttons Area  */
        .action-buttons-section { margin-bottom: var(--spacing-xlarge); }
        .action-buttons-container { display: flex; flex-wrap: wrap; justify-content: center; gap: var(--spacing-medium); }
        .action-buttons-container .btn { flex-grow: 1; min-width: 80px; }
        .action-buttons-container.movement-actions .btn { max-width: calc(25% - var(--spacing-medium)); min-width: 60px; }
        .action-buttons-container.combat-actions .btn { max-width: calc(33% - var(--spacing-medium)); min-width: 100px; }

        .hidden { display: none !important; }


        /* put this in your stylesheet */
        .fab-container {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            flex-direction: column;
            align-items: center;
            grid-template-areas:
                ".    up    ."
                "left center right"
                ".   down   .";
            grid-gap: 0rem;
            pointer-events: none;
            z-index: 1000;
        }
        .fab-container button {
            pointer-events: auto;
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            border: none;
            font-size: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: transform 0.1s ease;
        }
        .fab-container button:active {
            transform: scale(0.9);
        }

        /* area assignments */
        .btn-up    { grid-area: up;    }
        .btn-down  { grid-area: down;  }
        .btn-left  { grid-area: left;  }
        .btn-right { grid-area: right; }
        /* center can be used if you ever need a middle button */
        .btn-center { grid-area: center; }
        /* 1) Float the whole stats-area at top-left */
        .stats-area {
            font-size: 13px;
            line-height: 14px;
            position: fixed;
            top: 3rem;
            left: 1rem;
            z-index: 1000;
            /* let clicks pass through empty space if you want:
                pointer-events: none; */
            /* but allow interaction inside the box: */
            /* pointer-events: auto; */
        }

        /* 2) Sections themselves are transparent */
        .stats-section {
            background: transparent;
            margin-bottom: 0.5rem;   /* space between Player & Enemy boxes */
        }


        .stats-content span {
            color: #fff;
            line-height: 14px;
            /* four-way shadow to simulate an outline */
            text-shadow:
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px  1px 0 #000,
                1px  1px 0 #000;
            display: block;  /* one stat per line */
        }


        .stats-section h3 {
            margin: 0 0 0.25rem;
            color: #fff;
            text-shadow:
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px  1px 0 #000,
                1px  1px 0 #000;
        }

        @media (max-width: 600px) {
            body { padding: var(--spacing-medium); }
            .container { padding: var(--spacing-medium); }
            .page-title { font-size: 1.6rem; }
            h3 { font-size: var(--font-size-large); }

            .stats-area {
                position: fixed;
                top: 3rem;
                left: 0;
                right: 0;
                display: flex;
                justify-content: space-between;
                padding: 0 0.5rem;
                flex-direction: row; /* KEEP LEFT-RIGHT even on small screens */
                align-items: flex-start;
            }

            .stats-section {
                min-width: auto;
                max-width: 48%;     /* prevent overflow */
                box-sizing: border-box;
            }

            .stats-section h3 {
                font-size: 1.0rem;
                display: block;
            }

            .stats-content span {
                font-size: 0.65rem;
            }

            .action-buttons-container .btn {
                max-width: calc(50% - var(--spacing-medium));
                min-width: 100px;
            }

            .action-buttons-container.movement-actions .btn {
                font-size: 1.1rem;
            }
        }

        .player-name, .player-label {
            color: #4caf50;
            font-weight: bold;
        }

        .enemy-name, .enemy-label {
            color: #f44336;
            font-weight: bold;
        }

    </style>
</head>
<body>
<div class="container">

    <h2 id="page-title" class="page-title">Loading...</h2>

    <div id="loading-indicator" class="hidden" class="loading-indicator">Fetching game state...</div>
    <div id="error-message" class="error-message hidden" role="alert"></div>

    <section id="character-creation" class="form-section hidden">

        <h3>Create Character</h3>
        
        <form id="start-form">
        <div class="form-group">
        <label for="player-name">Name:</label>
        <input type="text" id="player-name" name="name" placeholder="Your name" required>
        </div>
        
        <div class="form-group">
        <label for="player-class">Class (1-8):</label>
        <input type="number" id="player-class" name="class" min="1" max="8" value="1" required>
        </div>
        
        <button type="submit" class="btn btn-primary">Start Game</button>
        </form>

        <div id="character-list" class="character-list"></div>
        
    </section>

    <section id="game-status" class="hidden">
        <button type="button" id="restart-button" class="btn btn-danger"> üîÑ </button>
        <button type="button" id="zoom-button" class="btn btn-secondary"> üîç </button>


        <div class="stats-area"> 
            <section id="player-section" class="stats-section">
              <h3>Player</h3>
              <div id="player-stats" class="stats-content" aria-live="polite">Loading...</div>
            </section>
          
            <section id="enemy-section" class="stats-section hidden">
              <h3>Enemy</h3>
              <div id="enemy-stats" class="stats-content" aria-live="polite"></div>
            </section>
        </div>
      

        <section class="map-section">
                <div class="map-header">
                    <!-- <h3>Map</h3> -->

                </div>
                <!-- The container for map/canvas, now centered -->
                <div class="map-area">
                    <img id="map-image" src="" alt="Game map (Loading...)">
                    <canvas id="map-canvas" width="100" height="100" class="hidden"></canvas>
                </div>
        </section>

        <!-- <hr class="separator"> -->
        <section class="log-section">
            <h3>Log</h3>
            <div id="log-content" aria-live="polite">Loading...</div>
        </section>

        <section id="action-buttons-section" class="action-buttons-section">
            <div id="action-buttons-container" class="action-buttons-container">
            </div>
        </section>


        <div id="game-over-message" class="game-over-message hidden">
            GAME OVER
        </div>
        

    </section>
</div>
    

<script>
    // --- DOM Elements ---
    const pageTitle = document.getElementById('page-title');
    const loadingIndicator = document.getElementById('loading-indicator');
    const errorMessage = document.getElementById('error-message');
    const characterCreationDiv = document.getElementById('character-creation');
    const gameStatusDiv = document.getElementById('game-status');
    const startForm = document.getElementById('start-form');
    const playerNameInput = document.getElementById('player-name');
    const playerClassInput = document.getElementById('player-class');
    const playerSectionDiv = document.getElementById('player-section');
    const playerStatsDiv = document.getElementById('player-stats');
    const enemySectionDiv = document.getElementById('enemy-section');
    const enemyStatsDiv = document.getElementById('enemy-stats');
    const mapSectionDiv = document.querySelector('.map-section');
    const mapAreaDiv = document.querySelector('.map-area');
    const mapImage = document.getElementById('map-image');
    const mapCanvas = document.getElementById('map-canvas');
    const canvasCtx = mapCanvas.getContext('2d');
    const zoomButton = document.getElementById('zoom-button');
    const logContentDiv = document.getElementById('log-content');
    const actionButtonsContainer = document.getElementById('action-buttons-container');
    const actionButtonsSection = document.getElementById('action-buttons-section');
    const restartButton = document.getElementById('restart-button');
    const gameOverMessage = document.getElementById('game-over-message');

    // --- Global Variables ---
    const API_URL = '/api/game_state';
    let currentState = null;
    let zoomActive = false;
    let playerIconImg = new Image();
    let enemyIconImg = new Image();

    function highlightLogText(logText, playerName, enemyName) {
  let result = logText;

  if (playerName) {
    const escapedPlayer = playerName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const playerRegex = new RegExp(`\\b(${escapedPlayer})\\b`, 'g');
    result = result.replace(playerRegex, '<span class="player-name">$1</span>');
  }

  if (enemyName) {
    const escapedEnemy = enemyName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const enemyRegex = new RegExp(`\\b(${escapedEnemy})\\b`, 'g');
    result = result.replace(enemyRegex, '<span class="enemy-name">$1</span>');
  }

  return result;
}

    
    document.addEventListener('DOMContentLoaded', async () => {
        // grab the elements you actually rendered:
        const list           = document.getElementById('character-list');


        // try to restore last-picked char
        let char = localStorage.getItem('selectedChar');

        // 1) load character thumbnails
        try {
            const res  = await fetch('./Characters/');
            const text = await res.text();
            const doc  = new DOMParser().parseFromString(text, 'text/html');

            const files = Array.from(doc.querySelectorAll('a'))
            .map(a => a.getAttribute('href'))
            .filter(h => /\.png$/i.test(h));

            files.forEach(file => {
            const img = document.createElement('img');
            img.src       = `./Characters/${file}`;
            img.alt       = file;
            img.className = 'char-thumb';
            
            // if this matches our restored selection, mark it now:
            if (file === char) {
                img.classList.add('selected');
                playerIconImg.src = img.src;
            }

            img.addEventListener('click', () => {
                // deselect everything, select this one
                document.querySelectorAll('.char-thumb.selected')
                .forEach(el => el.classList.remove('selected'));
                img.classList.add('selected');

                // store & update
                char = file;
                localStorage.setItem('selectedChar', char);
                playerIconImg.src = img.src;
            });

            list.appendChild(img);
            });
        } catch (e) {
            console.error('Could not list the files from ./Characters/', e);
        }

        // 2) default enemy icon stays constant for now
        enemyIconImg.src = "./Enemies/kobold_scout.png"; // placeholder

        // 3) ‚ÄúIniciar Jogo‚Äù ‚Äî now char is never null if reloaded:
        startForm.addEventListener('submit', e => {
            e.preventDefault();
            if (!char) {
                return alert('Please select a character before starting the game.');
            }
            handleStartGame(e);
        });

        // 4) other buttons
        restartButton.addEventListener('click', handleRestartGame);
        zoomButton.addEventListener('click', handleZoomToggle);

        // 5) get your initial state from the server
        sendAction('get_state');
    });


    // --- UI Update Functions ---

    function showLoading(isLoading) {
        loadingIndicator.classList.toggle('hidden', !isLoading);
        if (isLoading) errorMessage.classList.add('hidden');
    }
    function showError(message) {
        errorMessage.textContent = `Error: ${message}`;
        errorMessage.classList.remove('hidden');
        showLoading(false);
    }


    document.addEventListener('keydown', function(event) {
        const key = event.key.toLowerCase();

        // only respond to our control keys when you're not typing in an input
        if (['w','a','s','d','f','q','r'].includes(key) &&
            document.activeElement.tagName !== 'INPUT') {
            event.preventDefault();

            // map physical keys ‚Üí game action values
            const keyMap = {
            // movement
            w: 'n',  // up
            a: 'w',  // left
            s: 's',  // down
            d: 'e',  // right
            // combat
            f: 'a',  // attack
            q: 'sp', // special
            r: 't'   // run
            };

            const value = keyMap[key];
            if (!value) return;

            // look for the button inside our floating-D-pad container
            const btn = document.querySelector(`.fab-container button[value="${value}"]`);
            if (btn) btn.click();
        }
    });






    function updateUI(state) {
        currentState = state;
        showLoading(false);
        errorMessage.classList.add('hidden');

        if (!state) {
            showError('Received invalid state from server.');
            return;
        }

        if (state.needs_setup) {
            pageTitle.textContent = 'New Game - Dungeon Leveling';
            characterCreationDiv.classList.remove('hidden');
            gameStatusDiv.classList.add('hidden');
        } else {
            pageTitle.textContent = 'Dungeon Leveling';
            characterCreationDiv.classList.add('hidden');
            gameStatusDiv.classList.remove('hidden');
            const enemy = Array.isArray(state.enemies) && Number.isInteger(state.enemy) ? state.enemies[state.enemy] : false;

            renderPlayerStats(state.player);
            renderEnemyStats(enemy);
            renderMap(state); // Calls updated renderMap
            renderLog(state.log, state.player.name, enemy ? enemy.name : false );
            renderActionButtons(enemy, state.game_over);
            

            gameOverMessage.classList.toggle('hidden', !state.game_over);
            actionButtonsSection.classList.toggle('hidden', state.game_over);
        }
    }

    function renderPlayerStats(player) {
        if (player) {
            playerStatsDiv.innerHTML = `
                <span><strong class="player-label">Name:</strong> ${player.name || 'N/A'}</span>
                <span><strong class="player-label">HP:</strong> ${player.hp ?? 'N/A'} / ${player.max_hp ?? 'N/A'} (${player.hp && player.max_hp ? Math.round((player.hp / player.max_hp) * 100) + '%' : '0%'})</span>
                <span><strong class="player-label">Class:</strong> ${player.class_number ?? 'N/A'}</span>
                <span><strong class="player-label">Defense:</strong> ${player.def ?? 'N/A'}</span>
                <span><strong class="player-label">Attack:</strong> ${player.atk ?? 'N/A'}</span>
                <span><strong class="player-label">Special:</strong> ${player.special ?? 'N/A'}</span>`;
            playerSectionDiv.classList.remove('hidden');
        } else {
            playerStatsDiv.textContent = 'Player data unavailable.';
        }
    }

    function renderEnemyStats(enemy) {
        if (enemy) {
            enemyStatsDiv.innerHTML = `
                <span><strong class="enemy-label">Name:</strong> ${enemy.name || 'N/A'}</span>
                <span><strong class="enemy-label">HP:</strong> ${enemy.hp ?? 'N/A'} / ${enemy.max_hp ?? 'N/A'} (${enemy.hp && enemy.max_hp ? Math.round((enemy.hp / enemy.max_hp) * 100) + '%' : '0%'})</span>
                <span><strong class="enemy-label">Class:</strong> ${enemy.class_number ?? 'N/A'}</span>
                <span><strong class="enemy-label">Defense:</strong> ${enemy.def ?? 'N/A'}</span>
                <span><strong class="enemy-label">Attack:</strong> ${enemy.atk ?? 'N/A'}</span>
                <span><strong class="enemy-label">Special:</strong> ${enemy.special ?? 'N/A'}</span>`;
            enemySectionDiv.classList.remove('hidden');
        } else {
            enemyStatsDiv.innerHTML = '';
            enemySectionDiv.classList.add('hidden');
        }
    }


    function clearAllOverlays() {
        const wrapper = canvasCtx.canvas.parentElement;
        if (!wrapper) return;

        // grab both the single player overlay and any number of enemy overlays
        wrapper
            .querySelectorAll('#playerIconOverlay, .enemyIconOverlay')
            .forEach(el => el.remove());
    }
    
    function idToFilename(id) {
      return id.toLowerCase().replace(/\s+/g, '_') + '.png';
    }



    // --- renderMap ---
    // Handles showing/hiding image vs canvas and triggering updates
    function renderMap(state) {
        // Clear previous character icons (from non-zoomed view)
        mapAreaDiv.querySelectorAll('.character-icon').forEach(icon => icon.remove());

        // Set visibility based on zoom BEFORE loading image or drawing canvas
        mapImage.classList.toggle('hidden', zoomActive);
        mapCanvas.classList.toggle('hidden', !zoomActive);

        // Define the map update logic inside a function
        const updateMapVisuals = () => {
            // Clear icons again (safety check)
            mapAreaDiv.querySelectorAll('.character-icon').forEach(icon => icon.remove());

            if (zoomActive) {
                // Ensure canvas is visible, draw zoomed content
                mapImage.classList.add('hidden'); // Ensure hidden
                mapCanvas.classList.remove('hidden'); // Ensure visible
                drawZoomedMap(state); // Call the updated drawing function
            } else {
                if (canvasCtx) clearAllOverlays();
                
                // Ensure image is visible, place icons on it
                mapImage.classList.remove('hidden'); // Ensure visible
                mapCanvas.classList.add('hidden'); // Ensure hidden
                // Place icons only if image has rendered dimensions
                if (mapImage.offsetWidth > 0 && mapImage.offsetHeight > 0) {
                    placeIcons(state); // Place <img> icons
                } else {
                    // If dimensions are 0, wait for layout (usually handled by onload)
                    console.warn("Map image dimensions not ready for icon placement yet.");
                }
            }
        };

        // Set up image loading handlers
        mapImage.onload = updateMapVisuals; // Call visuals update when image loads/reloads
        mapImage.onerror = () => {
            console.error('Failed to load the map image:', mapImage.src);
            mapImage.alt = 'Failed to load map';
            mapAreaDiv.querySelectorAll('.character-icon').forEach(icon => icon.remove());
            mapSectionDiv.classList.add('hidden'); // Hide section on critical error
        };

        // Determine map source and trigger update
        const newMapPath = state.map_path || '';
        mapSectionDiv.classList.remove('hidden'); // Ensure section is visible

        if (!newMapPath) {
            mapImage.src = '';
            mapImage.alt = 'Map unavailable';
            mapCanvas.classList.add('hidden');
            mapImage.classList.remove('hidden'); // Show empty image element
            mapAreaDiv.querySelectorAll('.character-icon').forEach(icon => icon.remove());
        } else {
            const fullPath = window.location.origin + (newMapPath.startsWith('/') ? '' : '/') + newMapPath;
             // Only change src if it's actually different OR if the image failed before
            if (mapImage.src !== fullPath || !mapImage.complete || mapImage.naturalWidth === 0) {
                mapImage.src = newMapPath; // Setting src triggers onload
                mapImage.alt = 'Game Map';
            } else {
                // If src is the same AND image is loaded, manually update visuals
                // (e.g., when toggling zoom without changing map)
                updateMapVisuals();
            }
        }
    }


    function placeIcons(state) {
        const shape = state.map_shape;
        // --- Safety Checks ---
        if (!mapImage || !mapAreaDiv) {
            console.error("Map elements (mapImage or mapAreaDiv) not found.");
            return;
        }

        const mapWidth = mapImage.offsetWidth;
        const mapHeight = mapImage.offsetHeight;

        if (mapWidth <= 0 || mapHeight <= 0) {
            console.warn(`Cannot place icons: Invalid map dimensions (${mapWidth}x${mapHeight})`);
            return;
        }

        // --- Place Player Icon ---
        if (state.player && state.player.position) {
            try {
                let [relY, relX] = state.player.position;
                relY = relY/shape[0];
                relX = relX/shape[1];
                // Validate relative positions
                if (typeof relY !== 'number' || typeof relX !== 'number' || relY < 0 || relY > 1 || relX < 0 || relX > 1) {
                    console.warn(`Invalid player relative position: [${relY}, ${relX}]`);
                } else {
                    const y = relY * mapHeight;
                    const x = relX * mapWidth;
                    createIconElement(playerIconImg, 'Jogador', ['player-icon'], state.player.facing, x, y);
                }
            } catch (error) {
                console.error("Error processing player data:", error, state.player);
            }
        } else {
            console.log("No player data or position found in state.");
        }

        // --- Place Enemy Icons (Iterate through the list) ---
        if (state.enemies && Array.isArray(state.enemies)) {

            for (let i = 0; i < state.enemies.length; i++) { // Use a for loop for index access if needed for debugging
                const enemy = state.enemies[i];
                if (enemy && enemy.position) {
                    try {
                        let [relY, relX] = enemy.position;
                        relY = relY/shape[0];
                        relX = relX/shape[1];
                        // Validate relative positions
                        if (typeof relY !== 'number' || typeof relX !== 'number' || relY < 0 || relY > 1 || relX < 0 || relX > 1) {
                            console.warn(`Invalid enemy[${i}] relative position: [${relY}, ${relX}]`);
                            continue; // Skip this enemy
                        }
                        const y = relY * mapHeight;
                        const x = relX * mapWidth;
                        // Create a unique icon for each enemy using the preloaded image as a template
                        createIconElement(enemyIconImg, `Inimigo ${i + 1}`, ['enemy-icon'], enemy.facing, x, y); // Added index to alt text
                    } catch (error) {
                        console.error(`Error processing enemy[${i}] data:`, error, enemy);
                    }
                }
            }
        }
    }

    function createIconElement(imgElement, altText, classes, facing, x, y) {
        // Ensure the source image element is valid before cloning
        if (!(imgElement instanceof HTMLImageElement)) {
            console.error("Invalid image element passed to createIconElement:", imgElement);
            return;
        }

        const icon = imgElement.cloneNode(true); // Clone the preloaded image element
        icon.alt = altText;
        icon.classList.add('character-icon', ...classes); // Apply base and specific classes

        // Basic validation for x, y coordinates
        if (typeof x !== 'number' || typeof y !== 'number') {
            console.warn(`Invalid coordinates for icon "${altText}": (x=${x}, y=${y})`);
            // Set default position or skip appending? Let's default to 0,0 for now.
            x = 0;
            y = 0;
        }

        // Calculate rotation (ensure getRotation handles invalid 'facing' values)
        const rotation = getRotation(facing);

        // Center the icon on the coordinates (x, y) and apply rotation
        icon.style.position = 'absolute'; // Ensure absolute positioning for left/top
        icon.style.left = `${x}px`;
        icon.style.top = `${y}px`;
        icon.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;

        // Make sure mapAreaDiv exists before appending
        if (mapAreaDiv) {
            mapAreaDiv.appendChild(icon); // Append to the map area
        } else {
            console.error("mapAreaDiv is not available to append the icon:", icon);
        }
    }

    function drawZoomedMap(state) {
        const { player, enemies } = state;
        const shape = state.map_shape;
        const viewSize = 100;              // canvas width/height
        const zoomedIconSize = 48;         // final on‚Äëscreen icon size

        if (!canvasCtx) {
            console.error("Canvas context is not available.");
            return;
        }

        // clear and draw background slice
        canvasCtx.clearRect(0, 0, viewSize, viewSize);
        if (!player || !player.position || !mapImage.naturalWidth || mapImage.naturalWidth === 0) {
            // placeholder if map isn‚Äôt ready
            canvasCtx.fillStyle = 'grey';
            canvasCtx.fillRect(0, 0, viewSize, viewSize);
            canvasCtx.fillStyle = 'white';
            canvasCtx.textAlign = 'center';
            canvasCtx.fillText('Loading Map ...', viewSize / 2, viewSize / 2);
            return;
        }

        // Calculate player's absolute position on the natural image
        const [relY, relX] = player.position;
        const naturalW = mapImage.naturalWidth;
        const naturalH = mapImage.naturalHeight;
        const playerAbsX = relX/shape[1] * naturalW;
        const playerAbsY = relY/shape[0] * naturalH;

        // Determine viewport top-left (sx, sy) clamped within image bounds
        let sx = playerAbsX - viewSize / 2;
        let sy = playerAbsY - viewSize / 2;
        sx = Math.max(0, Math.min(sx, naturalW - viewSize));
        sy = Math.max(0, Math.min(sy, naturalH - viewSize));

        try {
            canvasCtx.drawImage(
                mapImage,
                sx, sy,
                viewSize, viewSize,
                0, 0,
                viewSize, viewSize
            );
        } catch (e) {
            console.error("Error drawing map image onto canvas:", e);
            canvasCtx.fillStyle = 'red';
            canvasCtx.fillRect(0, 0, viewSize, viewSize);
            canvasCtx.fillStyle = 'white';
            canvasCtx.textAlign = 'center';
            canvasCtx.fillText('Error drawing map', viewSize / 2, viewSize / 2);
            return;
        }

        // Prepare overlay container
        const wrapper = canvasCtx.canvas.parentElement;
        if (!wrapper) {
            console.error("Cannot find wrapper element for overlays.");
            return;
        }
        // Ensure wrapper is positioned relative for absolute children
        wrapper.style.position = 'relative';

        // ---------------------- Player Overlay ----------------------
        let playerOverlay = wrapper.querySelector('#playerIconOverlay');
        if (!playerOverlay) {
            playerOverlay = document.createElement('img');
            playerOverlay.id = 'playerIconOverlay';
            playerOverlay.src = playerIconImg.src;
            playerOverlay.style.position = 'absolute';
            playerOverlay.style.pointerEvents = 'none';
            wrapper.appendChild(playerOverlay);
        }
        playerOverlay.style.width = `${zoomedIconSize}px`;
        playerOverlay.style.height = `${zoomedIconSize}px`;
        playerOverlay.style.left = '50%';
        playerOverlay.style.top = '50%';
        const playerRotation = getRotation(player.facing);
        playerOverlay.style.transform = `translate(0%, 0%) rotate(${playerRotation}deg)`;

        // ---------------------- Enemy Overlays ----------------------
        // Remove old enemy overlays
        wrapper.querySelectorAll('.enemyIconOverlay').forEach(el => el.remove());

        if (Array.isArray(enemies)) {
            enemies.forEach((enemy, i) => {
                if (!enemy || !enemy.position) return;
                const [eRelY, eRelX] = enemy.position;
                // Validate relative position
                if (typeof eRelY !== 'number' || typeof eRelX !== 'number') return;

                // Compute absolute and local positions
                const enemyAbsX = eRelX/shape[1] * naturalW;
                const enemyAbsY = eRelY/shape[0] * naturalH;
                const localX = enemyAbsX - sx;
                const localY = enemyAbsY - sy;

                // Skip if outside viewport
                if (localX < 0 || localX > viewSize || localY < 0 || localY > viewSize) return;

                // Create overlay image for enemy
                const enemyOverlay = document.createElement('img');
                enemyOverlay.src = enemyIconImg.src; // idToFilename(enemy.name);
                enemyOverlay.classList.add('enemyIconOverlay');
                enemyOverlay.style.position = 'absolute';
                enemyOverlay.style.pointerEvents = 'none';
                enemyOverlay.style.width = `${zoomedIconSize}px`;
                enemyOverlay.style.height = `${zoomedIconSize}px`;
                // Position as percentage within wrapper
                enemyOverlay.style.left = `${(localX / viewSize) * 100}%`;
                enemyOverlay.style.top = `${(localY / viewSize) * 100}%`;
                const enemyRotation = getRotation(enemy.facing);
                enemyOverlay.style.transform = `translate(0%, 0%) rotate(${enemyRotation}deg)`;

                wrapper.appendChild(enemyOverlay);
            });
        }
    }


    function renderLog(logEntries, player_name, enemy_name) {
        logContentDiv.innerHTML = '';
        if (logEntries && logEntries.length > 0) {
            logEntries.forEach(entry => {
                const p = document.createElement('p');
                p.innerHTML = highlightLogText(entry, player_name, enemy_name);
                logContentDiv.appendChild(p);
            });
            logContentDiv.scrollTop = logContentDiv.scrollHeight;
        } else {
            logContentDiv.innerHTML = '<i>History Empty.</i>';
        }
    }

    function renderActionButtons(enemy, isGameOver) {
        const container = actionButtonsContainer;
        container.innerHTML = '';
        container.className = '';               // clear old classes
        if (isGameOver) {
            actionButtonsSection.classList.add('hidden');
            return;
        }
        actionButtonsSection.classList.remove('hidden');

        // make the floating-Dpad container
        container.classList.add('fab-container');

        // choose your 4 ‚Äúslots‚Äù based on mode
        const buttonDefs = enemy
            // COMBAT: Atk=Up, Special=Left, Run=Right, (no Down slot)
            ? [
                { pos: 'up',    value: 'a',  text: '‚öîÔ∏è', classes: ['btn-danger'] },
                { pos: 'left',  value: 'sp', text: '‚ú®', classes: ['btn-primary'] },
                { pos: 'right', value: 't',  text: 'üèÉ', classes: ['btn-secondary'] }
            ]
            // MOVEMENT: ‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è in their natural spots
            : [
                { pos: 'up',    value: 'n', text: '‚¨ÜÔ∏è', classes: ['btn-action'] },
                { pos: 'down',  value: 's', text: '‚¨áÔ∏è', classes: ['btn-action'] },
                { pos: 'left',  value: 'w', text: '‚¨ÖÔ∏è', classes: ['btn-action'] },
                { pos: 'right', value: 'e', text: '‚û°Ô∏è', classes: ['btn-action'] }
            ];

        // render each one into its grid‚Äêarea
        buttonDefs.forEach(({pos, value, text, classes}) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.value = value;
            btn.textContent = text;
            btn.classList.add(`btn-${pos}`, 'btn-fab', ...classes);
            btn.addEventListener('click', handleActionButtonClick);
            container.appendChild(btn);
        });
    }

    // --- Action Handling ---
    function handleActionButtonClick(event) {
        const action = event.target.value;
        if (action) sendAction(action);
    }


    async function sendAction(action, params = {}) {
        // showLoading(true);
        const urlParams = new URLSearchParams();
        urlParams.append('action', action);
        for (const key in params) { urlParams.append(key, params[key]); }
        const url = `${API_URL}?${urlParams.toString()}`;

        try {
            const response = await fetch(url, { cache: 'no-store' });
            if (!response.ok) {
                let errorText = `Error fetching the response: ${response.status} ${response.statusText}`;
                try {
                    const errorData = await response.json();
                    if (errorData && errorData.error) errorText = errorData.error;
                } catch (e) { /* Ignore non-JSON errors */ }
                throw new Error(errorText);
            }
            const state = await response.json();
            updateUI(state);
        } catch (error) {
            console.error("Action Failed:", action, error);
            showError(`Failed to communicate with the server: ${error.message}`);
            // showLoading(false);
        }
    }

    // --- Event Handlers ---
    function handleStartGame(event) {
        event.preventDefault();
        const name = playerNameInput.value.trim();
        const classNumber = playerClassInput.value;
        if (name && classNumber) {
            sendAction('start', { name: name, class: classNumber });
        } else {
            showError("Please fill in the name and class.");
        }
    }
    function handleRestartGame() {
        if (confirm("Are you sure you want to restart the game? All progress will be lost.")) {
            sendAction('restart');
        }
    }

    // --- handleZoomToggle ---
    function handleZoomToggle() {
        zoomActive = !zoomActive;
        zoomButton.textContent = zoomActive ? 'üó∫Ô∏è' : 'üîç';
        if (currentState) {
            renderMap(currentState);
        }
    }

    // --- Utility Functions ---
    function getRotation(facing = 's') {
        switch (facing) {
            case 'n': return 180; case 'e': return -90; case 'w': return 90; case 's': return 0; default: return 0;
        }
    }

</script>

</body>
</html>
